# trait特性与接口
- 特性来自接口，但比接口更多性质

//main.rs
```rs
//main.rs
fn main() {
    let square = Square {
        x: 0.0,
        y: 0.0,
        side: 1.0,
    };
    println!("square: ");
    print_area(square);

    let circle: Circle = Circle {
        x: 0.0,
        y: 0.0,
        radius: 2.0,
    };
    println!("circle: ");
    print_area(circle);

    
}
//特性是函数接口集合名
trait HasArea {
    fn area(&self) -> f64;
}

struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

struct Square {
    x: f64,
    y: f64,
    side: f64,
}

impl HasArea for Circle {
    fn area(&self) -> f64 {
        std::f64::consts::PI * (self.radius * self.radius)
    }
}

impl HasArea for Square {
    fn area(&self) -> f64 {
        self.side * self.side
    }
}

//T泛型类型实现HasArea，用于确保任何实现HasArea的类型将拥有.area()，可以调用HasArea的全部函数
fn print_area<T: HasArea>(shape: T) {
    println!("this shape has an area of {}", shape.area());
}

// use std::fmt::Debug;

// fn foo<T: Clone, K: Clone + Debug>(x: T, y: K) {
//     x.clone();
//     y.clone();
//     println!("foo函数y: {:?}", y);
// }

// fn bar<T, K>(x: T, y: K)
// where
//     T: Clone,
//     K: Clone + Debug,
// {
//     x.clone();
//     y.clone();
//     println!("bar函数y: {:?}", y);
// }

```

# 总结
- 为结构体实现特性
- 泛型类型实现特性(??)
