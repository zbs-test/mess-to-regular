# 函数补充
- 高阶函数允许把闭包作为参数来生成新的函数

// main.rs
```rs
//main.rs
fn main() {
    let transform: fn(i32) -> i32 = add_one;
    let f0 = add_one(2i32) * 2; //3*2
    let f1 = apply(add_one, 2); //3*2
    let f2 = apply(transform, 2); //3*2,效果等价于f1
    println!("f0:{} f1:{} f2:{}", f0, f1, f2);

    let closure = |x: i32| x + 1;
    let c0 = closure(2i32) * 2;
    let c1 = apply(closure, 2);
    let c2 = apply(|x| x + 1, 2);
    println!("c0:{} c1:{},c2:{}",c0,c1,c2);

    let box_fn = factory(1i32);//box_fn:(i32)->i32+1
    let b0 = box_fn(2i32)*2;
    let b1 = (*box_fn)(2i32)*2;
    let b2 =(& box_fn)(2i32)*2;
    println!("b0:{} b1:{},b2:{}",b0,b1,b2);
}
fn add_one(x: i32) -> i32 {
    x + 1
}
//高阶函数
/**
 * apply函数是这样看的：
 * para: 泛型参数类型F,i32
 * return: i32
 * where声明泛型参数类型F为函数类型：(i32)->i32
 * body: f(y)执行返回i32,（i32 * y）作为apply的返回值
 */
fn apply<F>(f: F, y: i32) -> i32
where
    F: Fn(i32) -> i32,
{
    f(y) * y
}

/**
 * factory:(i32) -> ((i32)->i32)
 * para:i32
 * return:Box<dyn (i32)->i32> ，Box装载的函数
 * body: 返回(x)->x+i32
 */
fn factory(x: i32) -> Box<dyn Fn(i32) -> i32> {
    Box::new(move |y| x + y)
}
```
# 总结
- 函数是第一公民吗??(golang)
- 以上函数用法全是来自函数式编程，建议先使用erlang，elixir，scala
- 没有真正的匿名函数和闭包，只不过:
    1. 是交付变量名
    2. 没有把他看作具名函数
